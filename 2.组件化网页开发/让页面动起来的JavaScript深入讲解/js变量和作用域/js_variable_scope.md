# js variable and scope

## 变量

数据
使用一次
使用多次的数据
变量的本质：保存数据的容器
统一操作、统一修改
$ _ 字母 数字
jQuery $
underscore 下划线
区分大小写
关键字 js 中有含义的字
保留字 关键字预留 之后会升级为关键字
命名要有意义
i/j/k

### 数据类型和堆栈

number, string, boolean, undefined, null;
array, object;

基本类型值不可修改
引用类型值可以修改
修改 vs 覆盖

replace 方法返回一个新的字符串
字符串方法都会返回一个新的字符串
无法在原有字符串上进行修改

delete person.gender
gender 性别
male
female

family

无法给基本类型添加属性

基本类型调用方法时，会寻找对应的包装对象
包装对象会将属性和方法借给基本类型

保存数据的位置
硬盘
堆栈

栈内存：有序排列，大小是固定的，不能扩建
堆内存：无须排列，相当别墅，空间大小不固定

基本类型保存在栈内存中，大小不可修改，比较好找
应用类型，可以修改，保存在堆内存中，在堆中开辟出一个地方，很难定位，需要知道地址，通过
地址定位到引用对象
地址保存到栈内存中
按值访问
按引用访问

引用类型保存在堆内存中

变量保存的值是什么：
保存基本类型的变量保存的是值本身
保存引用类型的变量保存的并不是对象本身，而是一个指向该对象的应用地址

### 变量相等比较和值比较

基本类型的变量比较
引用类型和引用类型比较：只有指向同一个引用才相等
指向对象的地址

复制变量的值
基本类型值的复制，两个值互不干涉

浅拷贝
深拷贝：涉及到递归的使用

undefined和null的值相等；

如果两个不同类型的数据进行==比较,会把左右转换成同一类型再比较,
如果一个运算数是对象，另一个是数字，会把对象转换成数字。

### 参数传递和类型检查

形参：定义时
实际参数：函数调用时
实参传递给了形参
基本类型
引用类型
实参，形参指向的是同一个地址

按值传递
按值传递，传递的是地址

按值访问
按引用访问

检查类型
number, string, boolean, undefined, null, array, object, function, regexp
typeof 运算符

object
[] instanceOf Array
前面的是后面的实例
instanceOf 与引用类型连用，不能与基本类型连用，基本类型一定会返回false

null是Null类型，属于基本类型，但是typeof null 返回的是字符串'object'；
instanceof不能检测基本数据类型，只要是基本数据类型和instanceof连用，返回的都是false。

## 作用域

作用域与解析机制
起作用的区域和范围
变量的生命周期，在哪里可以访问到变量
全局：
局部：函数作用域，函数体内部的执行环境

全局变量生命周期：当所有的程序执行完成后，全局作用域会被销毁
局部变量生命周期：函数执行完毕后，被销毁

因为不用var声明的变量是全局变量，y是全局变量，可以输出；x是局部变量，因此输出x会报错。

```js
function fn() {
  // 不用var声明的变量是全局变量
  var x = y = 1;
}
fn();

document.write(y); // 输出1
document.write(x); // 报错
```

变量对象和作用域链

window
作用域中的变量对象
局部作用域中的变量对象是程序员看不到，不可用的，js引擎又用到

作用域链
在作用域中查找变量
同名变量，越内层优先级越高
查找速度
jQuery
window
局部速度查找更快
压缩代码

with 延长作用域链

不存在的变量或函数会报错；不存在的属性或方法，返回undefined；

由于先绑定，后触发，给每个按钮绑定事件，但是在触发的时候i已经是循环完之后，i的值了。

### js 解析机制--预解析

变量提升
解析机制
预解析

把 argument 当作局部参数
预解析
执行
变量和函数冲突，函数胜
函数和函数冲突，在后面的胜

1. 以var 声明的变量 会预解析
2. 以let 声明的变量 不会进行预解析
3. 函数的声明会预解析
4. 函数表达式不进行预解析

fn函数在预解析时，已经提前进行了该函数的声明。

预解析机制详解
不通过var声明的变量是全局变量

预解析
找 var，function 后的变量

预解析阶段执行，然后，逐行执行代码
函数声明在预解析阶段执行
script 标签分别进行预解析+执行
预解析+执行

## 内存

内存管理与垃圾收集机制

垃圾收集机制：释放无用的数据，回收内存。
手动收集：
自动收集：
原理：找出没用的数据，打上标记，然后，释放内存，周期性的执行；
打上标记的策略：
标记清除：
  环境中的变量：变量还没有离开执行环境
  离开环境的变量：
引用计数：
  跟踪记录每个数据被引用的次数

循环引用
js: DOM和BOM
C++ COM

原生是标记清除的策略

A：为了获得更好的性能，我们需要及时解除无用数据的引用;
B：离开作用域的值不会立刻被回收，只是会被打上标记，在垃圾收集期间才会回收;
C：在老版本的IE中访问非原生JS对象(DOM和BOM元素)时，引用计数这种算法可能导致循环引用的问题;

计算数组[4]的引用次数是多少？
var a = [4]; // 1次
var b = a; // 2次
b = {}; // b的指向变了，所以是1次
b.arr = a; // 又被指向了1次，所以是2次
b = null; //b被清空了，所以最后是1次。

### 管理内存

web 浏览器
分配给 web浏览器的内存小于分配给桌面应用程序
只保存内存中有用的数据
设置为null，这叫做解除引用，使用于全局变量

不解除应用就像：跑步时，带个大沙包，会很耗性能

